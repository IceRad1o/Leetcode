[TOC]



## Leetcode 思路概述和经典题型总结

##### 数组

* 26删除有序数组中重复元素 , 80删除有序数组重复元素II。 (双指针)
* 4.两个正序数组的中位数, 33搜索旋转排序数组,  81搜索旋转排序数组II。 (二分查找)
*   

##### 链表

##### 二分查找

* 704 二分查找
* 33搜索旋转排序数组,  81搜索旋转排序数组II
* 34排序数组找第一个和最后一个位置
* 153寻找旋转排序数组中的最小值 154寻找旋转排序数组中的最小值 
* 4.两个正序数组的中位数

##### 深度优先搜索

DFS + 回溯: 这些DFS问题的结构大多类似, 包括一些二叉树的题也是利用DFS

- 39,40 组合总和, 77组合
- 46,47 全排列, 60第k个排列, 剑指offer38字符串全排列, 784字母大小写全排列
- 78子集, 90子集2
- 93IP地址复原, 22括号生成
- 搜索相关: 解数独, 79单词搜索, 130围绕的区域, 200岛屿数量, N皇后, 分割回文串, 二进制手表

##### 二叉树相关

##### 动态规划

* 509 斐波那契数列
* 322 零钱兑换
* 





##### Leetcode 思路概述

- [x] 1 数字之和

- [x] 2 两数相加

- [x] 3 无重复字符的最长子串

  注意区分: 字串substring 和子序列 subsequence的区别: 子串是连续的而子序列可以是非连续的

- [x] 4 两个正序数组的中位数 (归并 或者 二分查找 getKthElement)

- [x] 5 最长回文子串 (经典动态规划)

- [x] 6 Z字形变换 （建立一个row和inc，row是0或者size-1就把inc置反）

- [x] 7 整数反转

- [x] 8 atoi (scan,或者状态机)

- [x] 9 回文数 (反转一半数字)

- [x] 10 正则表达式 （动态规划）

- [x] 11 最多水的容器 （双指针向里面收缩）

- [x] 12 integer to roman （从大到小建立roman和nums的数组，使用贪心）

- [ ] 13 roman to integer

- [x] 14 最长公共前缀 （竖向比较）

- [x] 15 三数之和 （双指针）

- [x] 16 最接近的三树之和 （双指针）

- [ ] 17 电话号码的组合

- [ ] 18 4数之和

- [x] 19 删除链表倒数第N个节点 (快慢指针)

- [x] 20 有效括号 (左括号入栈, 如果是右括号, 用一个栈匹配最近的左括号)

- [x] 21 合并两个有序链表 (很简单的归并)

- [x] 22 括号生成 (回溯+dfs)

- [x] 23 合并k个升序链表 (通过merge的方法来合并, 可以使用21的代码mergetwo) 

- [x] 24 两两交换链表中的节点 (简单的链表换位)

- [x] 25 K个一组翻转链表 (遍历长度总长度后, 使用头插法)

- [x] 26 删除排序数组中的重复项 (双指针,设置一个index, 用for循环的i作为第二个指针 )

- [ ] 27 移除元素

- [ ] 28

- [ ] 29

- [ ] 30串联所有单词字串

- [x] 31下一个排列

- [ ] 32 最长有效括号

- [x] 33 搜索旋转排序数组 (二分查找, 条件较多, 要注意=)

- [x] 34 在排序数组中找到第一个和最后一个位置 (二分查找)

- [x] 35 搜索插入位置: 很简单 if(nums[i]>=target) return i

- [ ] 36 有效的数独

- [ ] 37 解数独

- [ ] 38 外观数列 

- [x] 39 组合总和1 经典dfs

- [x] 40 组合总和2 经典dfs

- [x] 41 缺失的第一个正数( 缺失的一定在0-N-1之间,把数组本身作为hashmap即可)

- [x] 42 接雨水 (暴力搜索两侧, 或者单调栈)

- [ ] 43 字符串相乘 

- [ ] 44 通配符匹配(和10类似, 动态规划或者贪心)

- [ ] 45 跳跃游戏2(贪心)

- [x] 46 全排列  dfs(回溯)

- [x] 47 全排列2 在46的基础上剪枝即可

- [x] 48 先转置矩阵(每个matrix ij 和matrix ji交换), 再每行reverse

- [x] 49 异味词分组(关键数据结构 unordered_map<string, vector\<string>) m

- [x] 50 Pow (快速幂)

- [ ] 51 N皇后

- [ ] 52 N皇后2

- [x] 53 最大子序和

- [x] 54 螺旋矩阵 (顺时针打印)

- [x] 55 跳跃游戏( 贪心or 动规)

- [x] 56 合并区间 

- [x] 57 插入区间

- [x] 58 最后一个单词长度

- [ ] 59

- [x] 60 第k个排列 (数学+缩小规模 或者 dfs+剪枝 或者是有序数组模拟)

- [x] 61 旋转链表, 每个节点向右移动k个位置 (首尾相连, 然后移动 len-k%len)

- [x] 62  不同路径 (数学)

- [x] 63  不同路径2

- [x] 64  最小路径和 (经典dp)

- [ ] 65  有效数字

- [x] 66  加一

- [ ] 67 二进制求和

- [ ] 68 左右文本对齐

- [ ] 69 sqrt(二分查找)

- [x] 70 爬楼梯

- [ ] 71 简化路径

- [x] 72 编辑距离(典型的动规, 一定要熟练)

- [ ] 73 矩阵置0

- [ ] 74 搜索二维矩阵

- [x] 75 颜色分类 ( 双指针 + 或者是经典的快排partition的过程)

- [ ] 76 最小覆盖字串

- [x] 77 组合 (经典dfs+回溯)

- [x] 78 子集 (经典dfs+回溯)

- [x] 79 单词搜索 (经典的搜索题)

- [x] 80 删除排序数组中的重复项2

- [ ] 81 搜索旋转排序数组2

- [ ] 82 

- [ ] 83

- [ ] 84

- [ ] 85

- [ ] 86

- [ ] 87

- [ ] 88

- [ ] 89

- [ ] 90子集2

- [ ] 91解码方法

- [ ] 92 反转链表2(位置m到n)

- [ ] 93

- [ ] 94

- [ ] 95

- [ ] 96

- [ ] 97

- [ ] 98

- [ ] 99

- [ ] 100

- [x] 101对称二叉树 (递归)

- [x] 102 二叉树层序遍历 

- [x] 103 二叉树锯齿层序遍历

- [x] 104 二叉树最大深度 (递归)

- [ ] 105

- [ ] 106

- [ ] 107

- [ ] 108

- [ ] 109

- [ ] 110

- [ ] 111

- [ ] 112

- [ ] 113

- [ ] 114

- [ ] 115

- [ ] 116

- [ ] 117

- [ ] 118

- [ ] 119

- [ ] 120 
- [ ] 121 买卖股票1 
- [ ] 122
- [ ] 123
- [ ] 124 二叉树最大路径和
- [ ] 125
- [ ] 126
- [ ] 127
- [ ] 128
- [ ] 129
- [ ] 130
- [ ] 131
- [ ] 132
- [ ] 133
- [ ] 134
- [ ] 135
- [ ] 146
- [ ] 137
- [ ] 138
- [ ] 139 
- [ ] 140
- [ ] 141
- [ ] 142
- [x] 143 重排链表
- [x] 144 二叉树前序遍历 
- [x] 145 二叉树后序遍历
- [x] 146 LRU(频率很高,一定要会) 
- [ ] 147
- [ ] 148
- [ ] 149
- [ ] 150
- [ ] 157
- [x] 198 打家劫舍
- [x] 199 二叉树右视图
  - 层次遍历, reverse过来取第一个即可
  - dfs 先序遍历, 先遍历右节点
- [x] 206 反转链表
- [ ] 213 打家劫舍2(house robber)
- [ ] 214 最短的回文
- [x] 215 数组中第K大的元素 : 基于快排序的partition 或基于堆排序的优先队列
- [x] 235 二叉搜索树最近公共祖先
- [ ] 300 最长上升子序列 (dp或者贪心+二分查找)



## 剑指offer

- [ ] 39 数组中出现次数超过一半的数字(1.排序,中间的数字就是结果 2.hashmap统计次数 3.摩尔投票)
- [ ] 52 两个链表的第一个公共节点 (1.用hashmap遍历链表A后再遍历B  2.统计长度, 长的先走 3.双指针)
- [ ] 

## 其他

